#!/bin/bash

set -e

: << =cut

=head1 NAME

loggrepx - Counts the number of matching log lines by log file

=head1 DESCRIPTION

This plugin is somewhat of a bash port of the original loggrep plugin,
except that it adds a breakdown of matches per file, rather than aggregating
matches across all files.

=head1 CONFIGURATION

The plugin can be included multiple times to create graphs for various
differing kinds of information in your log files. For example, you may
want to monitor the occurrence of 5xx errors in your webserver logs, but
also the occurrence of alert|critical|emergency entries in your syslog.

You can accomplish this by linking the plugin twice and providing
different criteria for each instance.

Note that most instances will probably work best when run as root, since
log files are usually (or at least should be) controlled with strict
permissions.

Available config options include the following:

 env.logfiles         - Files to grep (shellglob) (required)
 env.regex            - Regex to look for (required)
 env.title            - Graph title
 env.warning          - Default warning level
 env.critical         - Default critical level
 env.[field]_label    - Label to use for a specific logfile
 env.[field]_warning  - Warning level for specific logfile
 env.[field]_critical - Critical level for specific logfile

NOTE: for any variable with [field] in it, [field] is derived from the
full logfile path by simply replacing all non-alphanumerics with
underscores. For example, the "warning" field for the logfile
\`/var/log/nginx/errors.log\` would be \`var_log_nginx_errors_log_warning\`

One good way to get these names is to run \`munin-run [plugin-name]\`
after you've configured the required variables and then just copy/pasting
the names from the output.

=head1 AUTHOR

Kael Shipman <kael.shipman@gmail.com>

=head1 LICENSE

Copyright 2018 Kael Shipman<kael.shipman@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

=head1 MAGIC MARKERS

 #%# family=manual

=cut


# Get list of all currently set env variables
vars="$(printenv | sed -r "s/^([^=]+).*/\1/g")"

# Certain variables MUST be set; check that they are (using bitmask)
setvars=0
reqvars=(_logfiles _regex)
while read -u 3 -r v; do
    n=0
    while [ $n -lt "${#reqvars[@]}" ]; do
        if echo "$v" | egrep -q "${reqvars[$n]}$"; then
            !((setvars|=$(( 2 ** $n )) ))
        fi
        !((n++))
    done
done 3< <(echo "$vars")


# Sum all required variables
n=0
allvars=0
while [ $n -lt "${#reqvars[@]}" ]; do
    !((allvars+=$(( 2 ** $n ))))
    !((n++))
done

# And scream if something's not set
if ! [ "$setvars" -eq "$allvars" ]; then
    >&2 echo "E: Missing some required variables:"
    >&2 echo
    n=0
    i=1
    while [ $n -lt "${#reqvars[@]}" ]; do
        if [ $(( $setvars & $i )) -eq 0 ]; then
            >&2 echo "   *${reqvars[$n]}"
        fi
        i=$((i<<1))
        !((n++))
    done
    >&2 echo
    >&2 echo "Please read the docs."
    exit 1
fi

# Check for more difficult variables
if [ -z "$services" ] && [ -z "$services_autoconf" ]; then
    >&2 echo "E: You must pass either \$services or \$services_autoconf"
    exit 1
fi
if [ -z "$services_autoconf" ] && ! echo "$vars" | grep -q "_logbinding"; then
    >&2 echo "E: You must pass either \$*_logbinding (for each service) or \$services_autoconf"
    exit 1
fi


# Now go find all log files
LOGFILES=
declare -a LOGFILEMAP
while read -u 3 -r v; do
    if echo "$v" | egrep -q "_logfiles$"; then
        # Get the name associated with these logfiles
        logfiletype="${v%_logfiles}"
        # This serves to expand globs while preserving spaces (and also appends the necessary newline)
        while IFS= read -u 4 -r -d$'\n' line; do
            LOGFILEMAP+=($logfiletype)
            LOGFILES="${LOGFILES}$line"$'\n'
        done 4< <(IFS= ; for f in ${!v}; do echo "$f"; done)
    fi
done 3< <(echo "$vars")


# Set some defaults and other values
title="${title:-Important Events per Service}"
vlabel="${vlabel:-events}"

# If services_autoconf is passed, it is assumed to be a shell glob, the leaves of which are the services
# This also autobinds the service, if not already bound
if [ -n "$services_autoconf" ]; then
    declare -a services
    IFS=
    for s in $services_autoconf; do
        s="$(basename "$s")"
        services+=("$s")

        nm="$(echo "$s" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"
        v="${nm}_logbinding"
        if [ -z "${!v}" ]; then
            typeset "$v=$s"
        fi
    done
    unset IFS
else
    services=($services)
fi

    
# Import munin functions
#. "$MUNIN_LIBDIR/plugins/plugin.sh"


# Now get to the real function definitions

function config() {
    echo "graph_title ${title}"
    echo "graph_args --base 1000 -l 0"
    echo "graph_vlabel ${vlabel}"
    echo "graph_category events"
    echo "graph_info Lists number of matching lines found in various logfiles associated with each service"

    while read -u 3 -r svc; do
        nm="$(echo "$svc" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"
        echo "$nm.label $svc"
        #print_warning "$nm"
        #print_critical "$nm"
        echo "$nm.info Number of event occurrences for $svc"
    done 3< <(IFS=$'\n'; echo "${services[*]}")
}




function fetch() {
    # Load state
    touch "$MUNIN_STATEFILE"
    . "$MUNIN_STATEFILE"

    local n svcnm service svc svc_counter logbinding logfile lognm logmatch prvlines curlines matches

    # Set service counters to 0
    while read -u 3 -r svc; do
        svcnm="$(echo "$svc" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"
        typeset "${svcnm}_total=0"
    done 3< <(IFS=$'\n'; echo "${services[*]}")

    n=0
    while read -u 3 -r logfile; do
        # Handling trailing newline
        if [ -z "$logfile" ]; then
            continue
        fi

        # Find which service this logfile is associated with
        service=
        while read -u 4 -r svc; do
            logbinding="$(echo "$svc" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')_logbinding"
            if echo "$logfile" | egrep -q "${!logbinding}"; then
                service="$svc"
                break
            fi
        done 4< <(IFS=$'\n'; echo "${services[*]}")

        # Skip this log if it's not associated with any service
        if [ -z "$service" ]; then
            >&2 echo "W: No service associated with log $logfile. Skipping...."
            continue
        fi

        # Get shell-compatible names for service and logfile
        svcnm="$(echo "$service" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"
        lognm="$(echo "$logfile" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"

        # Get previous line count to determine whether or not the file may have been rotated
        prvlines="$(eval "echo \$${lognm}_lines")"
        if [ -z "$prvlines" ]; then
            prvlines=0
        fi

        # Get the current number of lines in the file
        curlines="$(wc -l "$logfile" | egrep -o '^[0-9]+')"
        if ! [ "$curlines" -eq "$curlines" ] &>/dev/null; then
            curlines=0
        fi

        # If the current line count is less than the previous line count, we've probably rotated.
        # Reset to 0.
        if [ "$curlines" -lt "$prvlines" ]; then
            prvlines=0
        else
            prvlines=$((prvlines + 1))
        fi

        # Get incidents starting at the line after the last line we've seen
        logmatch="${LOGFILEMAP[$n]}_regex"
        matches="$(tail -n +"$prvlines" "$logfile" | egrep -c "${!logmatch}" || true)"

        # Aggregate and add to the correct service counter
        svc_counter="${svcnm}_total"
        !((matches+=${!svc_counter}))
        typeset "$svc_counter=$matches"

        # Update the statefile
        sed -i "/^${lognm}_.*/d" "$MUNIN_STATEFILE"
        echo "${lognm}_lines=$curlines" >> "$MUNIN_STATEFILE"
        !((n++))
    done 3< <(echo "$LOGFILES")

    # Now echo values
    while read -u 3 -r svc; do
        svcnm="$(echo "$svc" | sed -r 's/^[^a-zA-Z]+//g' | sed -r 's/[^a-zA-Z0-9]+/_/g')"
        svc_counter="${svcnm}_total"
        echo "${svcnm}.value ${!svc_counter}"
    done 3< <(IFS=$'\n'; echo "${services[*]}")

    return 0
}





case "$1" in
    autoconf) echo no; exit 0 ;;
    config) config ;;
    *) fetch ;;
esac

